/*
 * This file was generated by the Gradle 'init' task.
 */

plugins {
    id 'war'
}

repositories {
    mavenLocal()
    mavenCentral()
}

dependencies {
    // Container-provided Jakarta EE APIs
    providedCompile libs.jakarta.platform.jakarta.jakartaee.api
    providedCompile libs.jakarta.ws.rs.jakarta.ws.rs.api
    providedCompile libs.jakarta.persistence.jakarta.persistence.api
    providedCompile libs.jakarta.ejb.jakarta.ejb.api

    // Application libraries to bundle
    implementation libs.com.auth0.java.jwt
    implementation libs.com.google.guava.guava
    implementation libs.org.hibernate.hibernate.core
    implementation libs.org.postgresql.postgresql

    // Test dependencies
    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.9.3'
    testImplementation 'org.junit.jupiter:junit-jupiter-engine:5.9.3'
    testImplementation 'org.mockito:mockito-core:5.6.0'
    testImplementation 'org.mockito:mockito-junit-jupiter:5.6.0'
}


group = 'org.example'
version = '1.0-SNAPSHOT'

// Configure WAR artifact name to match expected deployment name
war {
    archiveBaseName.set('AreaChecker')
    archiveVersion.set('')
}

// Custom tasks and settings

def scpHost = project.findProperty('scpHost') ?: ''
def scpUser = project.findProperty('scpUser') ?: ''
def scpPath = project.findProperty('scpPath') ?: ''

// compile: compilation of the project source codes
tasks.register('compile') {
    group = 'build'
    description = 'Compilation of the project source codes.'
    dependsOn tasks.named('compileJava')
}

// ensure build depends on compile
tasks.named('build') {
    dependsOn 'compile'
    description = 'Compile project source codes and package into executable archive.'
}

// test: launch junit tests, build if needed
tasks.named('test') {
    description = 'Launch junit-tests of the project. Builds project if needed.'
    useJUnitPlatform()

    def testResults = []
    def maxNameLength = 0
    def currentTestIndex = 0
    def totalTests = 0
    def paddingCount = 100

    beforeTest { descriptor ->
        def fullName = "${descriptor.className} > ${descriptor.name}"
    }

    afterTest { descriptor, result ->
        currentTestIndex++
        def fullName = "${descriptor.className} > ${descriptor.name}"
        def padding = " " * (paddingCount - fullName.length()-currentTestIndex.toString().length())
        def counter = "[${currentTestIndex}]"
        def statusColor
        def statusText = result.resultType.toString()
        switch (result.resultType) {
            case org.gradle.api.tasks.testing.TestResult.ResultType.SUCCESS:
                statusColor = "\u001B[32m"
                break
            case org.gradle.api.tasks.testing.TestResult.ResultType.FAILURE:
                statusColor = "\u001B[31m"
                break
            case org.gradle.api.tasks.testing.TestResult.ResultType.SKIPPED:
                statusColor = "\u001B[33m"
                break
            default:
                statusColor = "\u001B[0m"
        }

        println "${counter}${fullName}${padding}  ${statusColor}${statusText}\u001B[0m"

        testResults << result.resultType
    }

    afterSuite { desc, result ->
        if (!desc.parent) {
            // Получаем общее количество тестов из результата выполнения
            totalTests = result.testCount
            def passed = result.successfulTestCount
            def failed = result.failedTestCount
            def skipped = result.skippedTestCount

            println ""
            println "Test summary: "
            println "  Total   : ${totalTests}"
            println "  Passed  : \u001B[32m${passed}\u001B[0m"
            println "  Failed  : \u001B[31m${failed}\u001B[0m"
            println "  Skipped : \u001B[33m${skipped}\u001B[0m"
        }
    }
}



// scp: move the built war via scp after build
tasks.register('scp', Exec) {
    group = 'deployment'
    description = 'Move the built war via scp to the selected server.'
    dependsOn 'build'
    doFirst {
        if (!scpHost || !scpUser || !scpPath) {
            throw new GradleException("scpHost, scpUser, scpPath must be set via -P or gradle.properties")
        }
    }
    def artifact = tasks.named('war').get().archiveFile.get().asFile
    commandLine 'scp', artifact.absolutePath, "${scpUser}@${scpHost}:${scpPath}"
}

import java.util.Properties

// Load env.properties if present
def envFile = file('env.properties')
def envProps = new Properties()
if (envFile.exists()) {
    envFile.withInputStream { stream ->
        envProps.load(stream)
    }
}

/*
52 → Java 8
53 → Java 9
54 → Java 10
55 → Java 11
56 → Java 12
57 → Java 13
58 → Java 14
59 → Java 15
60 → Java 16
61 → Java 17
*/
// to proof version
// unzip /home/user/Desktop/gradle/lab4/backend/build/libs/AreaChecker.war -d /home/user/Desktop/gradle/lab4/backend/build/libs/ && javap -v /home/user/Desktop/gradle/lab4/backend/build/libs/WEB-INF/classes/com/example/AreaChecker/controller/GlobalBean.class | grep major
tasks.register('env', Exec) {
    group = 'build'
    description = 'Build using javaHome and jvmArgs from env.properties'

    // Pull values (and fail fast if javaHome is missing)
    def javaHome = envProps.getProperty('javaHome')
    if (!javaHome) {
        throw new GradleException("env.properties must define javaHome")
    }
    def jvmArgsProp = envProps.getProperty('jvmArgs', '')

    // Construct JVM‑system‑properties arguments
    def sysPropsArgs = [
        "-Dorg.gradle.java.home=${javaHome}"
    ]
    if (jvmArgsProp) {
        sysPropsArgs << "-Dorg.gradle.jvmargs=${jvmArgsProp}"
    }

    // Final command: gradlew -Dorg.gradle.java.home=... [-Dorg.gradle.jvmargs=...] build
    commandLine 'gradle', *sysPropsArgs, 'build'
}

